/Auth.jsx :

import React, { useState } from 'react'
import { Alert, StyleSheet, View } from 'react-native'
import { supabase } from '../lib/supabase'
import { Button, Input } from '@rneui/themed'

export default function Auth() {
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [loading, setLoading] = useState(false)

  async function signInWithEmail() {
    setLoading(true)
    const { error } = await supabase.auth.signInWithPassword({
      email: email,
      password: password,
    })

    if (error) Alert.alert(error.message)
    setLoading(false)
  }

  async function signUpWithEmail() {
    setLoading(true)
    const {
      data: { session },
      error,
    } = await supabase.auth.signUp({
      email: email,
      password: password,
    })

    if (error) Alert.alert(error.message)
    if (!session) Alert.alert('Please check your inbox for email verification!')
    setLoading(false)
  }

  return (
    <View style={styles.container}>
      <View style={[styles.verticallySpaced, styles.mt20]}>
        <Input
          label="Email"
          leftIcon={{ type: 'font-awesome', name: 'envelope' }}
          onChangeText={(text) => setEmail(text)}
          value={email}
          placeholder="email@address.com"
          autoCapitalize={'none'}
        />
      </View>
      <View style={styles.verticallySpaced}>
        <Input
          label="Password"
          leftIcon={{ type: 'font-awesome', name: 'lock' }}
          onChangeText={(text) => setPassword(text)}
          value={password}
          secureTextEntry={true}
          placeholder="Password"
          autoCapitalize={'none'}
        />
      </View>
      <View style={[styles.verticallySpaced, styles.mt20]}>
        <Button title="Sign in" disabled={loading} onPress={() => signInWithEmail()} />
      </View>
      <View style={styles.verticallySpaced}>
        <Button title="Sign up" disabled={loading} onPress={() => signUpWithEmail()} />
      </View>
    </View>
  )
}

const styles = StyleSheet.create({
  container: {
    marginTop: 40,
    padding: 12,
  },
  verticallySpaced: {
    paddingTop: 4,
    paddingBottom: 4,
    alignSelf: 'stretch',
  },
  mt20: {
    marginTop: 20,
  },
})

------------------------

/camera\FoodScannerScreen.tsx :

import React, { useCallback } from 'react';
import { SafeAreaView, StyleSheet, Alert, View } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { useRouter } from 'expo-router';
import AsyncStorage from '@react-native-async-storage/async-storage';

// Import Hooks
import { useImagePickerPermission } from '../../hooks/useImagePickerPermission'; // Adjust path
import { useFoodScanner } from '../../hooks/useFoodScanner'; // Adjust path

// Import Presentational Components
import { CameraInstructionView } from '../foodScanner/CameraInstructionView'; // Adjust path
import { PreviewView } from '../foodScanner/PreviewView'; // Adjust path
import LoadingSpinner from "../foodScanner/LoadingSpinner";
import { ResultsView } from '../foodScanner/ResultsView'; // Adjust path
import { PermissionLoadingView } from '../common/PermissionLoadingView'; // Adjust path
import { PermissionDeniedView } from '../common/PermisionDeniedView'; // Adjust path
import { ErrorFallbackView } from '../common/ErrorFallBackView'; // Example for fallback

// Import types
import { FoodItem, Meal, MealFoodItem } from '../../types/index'; // Adjust path

export default function FoodScannerScreen() {
  const navigation = useNavigation();
  const router = useRouter();
  const [hasPermission, requestPermission] = useImagePickerPermission();
  const {
    captureState,
    capturedImage,
    recognizedFood,
    isLoading,
    takePicture, // Use this as the action for CameraInstructionView
    handleRetake, // Use this for PreviewView and potential ResultsView back action
    handleAnalyze, // Use this for PreviewView
  } = useFoodScanner();

  // Logic requiring navigation/router/storage stays here
  const handleAddToLog = useCallback(async () => {
    if (!recognizedFood || recognizedFood.length === 0) {
      Alert.alert('No Foods', 'No recognized foods available to add!');
      return;
    }
    try {
      const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      const storedMealsJSON = await AsyncStorage.getItem('todayMeals');
      let todayMeals: Meal[] = [];
      try {
        if (storedMealsJSON) {
          todayMeals = JSON.parse(storedMealsJSON);
          if (!Array.isArray(todayMeals)) todayMeals = [];
        }
      } catch { todayMeals = []; }

      // Ensure mapping matches MealFoodItem if you defined that
      const newMeal: Meal = {
        id: `scan-${Date.now()}`,
        name: recognizedFood[0]?.name || 'Food Scan', // Use first item name?
        time,
        foods: recognizedFood.map((food: FoodItem): MealFoodItem => ({ // Explicit return type
          id: `food-${Date.now()}-${Math.random().toString(16).slice(2)}`,
          quantity: 100, // Default quantity
          name: food.name,
          kcal: Number(food.kcal) || 0,
          protein: Number(food.protein) || 0,
          carbs: Number(food.carbs) || 0,
          fats: Number(food.fats) || 0,
        })),
      };
      todayMeals.push(newMeal);
      await AsyncStorage.setItem('todayMeals', JSON.stringify(todayMeals));
      navigation.getParent()?.setParams({ mealsUpdated: Date.now() });
      Alert.alert('Success', 'Food added to your log!');
      router.push('/(tabs)/home');
    } catch (error: unknown) {
      let msg = 'Could not save food log.';
      if (error instanceof Error) msg = error.message;
      console.error('Log error:', error);
      Alert.alert('Error', msg);
    }
  }, [recognizedFood, navigation, router]);

  // Conditional Rendering Logic
  const renderContent = () => {
    if (hasPermission === null) {
      return <PermissionLoadingView />;
    }

    if (hasPermission === false) {
      return <PermissionDeniedView onGrantPermission={requestPermission} onGoBack={() => navigation.goBack()} />;
    }

    // Permission granted
    switch (captureState) {
      case 'camera':
        // *** Add this wrapping View with centering styles ***
        return (
          <View style={styles.centeredContainer}>
            <CameraInstructionView onLaunchCamera={takePicture} />
          </View>
        );
      case 'preview':
        // PreviewView likely has flex: 1 itself, assuming its styles are correct
        return capturedImage ? (
          <PreviewView
            imageUri={capturedImage.uri}
            isLoading={isLoading}
            onRetake={handleRetake}
            onAnalyze={handleAnalyze}
          />
        ) : <ErrorFallbackView message="No image captured." onRetry={handleRetake} />;
      case 'analyzing':
        // *** Add this wrapping View for centering ***
        return (
          <View style={styles.centeredContainer}>
            <LoadingSpinner/>
          </View>
        );
      case 'results':
        // ResultsView likely has flex: 1 itself
        return recognizedFood && recognizedFood.length > 0 ? (
          <ResultsView
            imageUri={capturedImage?.uri}
            foodData={recognizedFood}
            onAddToLog={handleAddToLog}
          />
        ) : (
          <ErrorFallbackView message="Could not identify food items." onRetry={handleRetake} retryLabel="Try Again" />
        );
      case 'error':
        return <ErrorFallbackView message="An error occurred during scanning." onRetry={handleRetake} />;
      default:
        return <ErrorFallbackView message="An unexpected error occurred." onRetry={handleRetake} />;
    }
  };

  return (
    // Apply base styles or let children handle flex: 1
    <SafeAreaView style={styles.safeArea}>
      {renderContent()}
    </SafeAreaView>
  );
}

// Minimal styles needed for the main screen container
const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: '#f8fafc', // Consistent background
  },
  centeredContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  // Keep container/error styles if ErrorFallbackView isn't used for all cases
  container: { flex: 1, justifyContent: 'center', alignItems: 'center', padding: 20 },
  errorText: { fontSize: 18, fontWeight: '600', color: '#334155', textAlign: 'center', marginBottom: 10 },

});

------------------------

/camera\FoodScannerScreen_legacy.tsx :

// // --- START OF FILE FoodScannerScreen.tsx ---
// // PART 1 of 3

// import React, { useState, useEffect, useCallback } from 'react';
// import {
//   View,
//   Text,
//   Image,
//   TouchableOpacity,
//   StyleSheet,
//   Alert,
//   ActivityIndicator,
//   Platform,
//   SafeAreaView,
//   StatusBar,
//   ScrollView,
//   Dimensions,
//   Button, // Added Button for permission request
// } from 'react-native';
// import * as ImagePicker from 'expo-image-picker';
// import { ImagePickerAsset } from 'expo-image-picker'; // Import the type for image assets
// import AsyncStorage from '@react-native-async-storage/async-storage';
// import { useNavigation } from '@react-navigation/native'; // Keep for goBack maybe
// import { useRouter } from 'expo-router'; // Correct import for Expo Router
// import { Ionicons } from '@expo/vector-icons';
// import axios from 'axios'; // Ensure axios types are installed (@types/axios if needed, but usually included)

// // Define an interface for the expected food item structure from your API
// interface FoodItem {
//   // Assuming id is generated locally, API might not return it in the initial list
//   // id: string;
//   name: string;
//   kcal: number;
//   protein: number;
//   carbs: number;
//   fats: number;
//   // Add other properties if your API returns more
// }

// export default function FoodScannerScreen() {
//   const navigation = useNavigation();
//   const router = useRouter(); // Initialize Expo Router

//   // --- STATES ---
//   const [hasPermission, setHasPermission] = useState<boolean | null>(null); // Type: boolean or null
//   const [captureState, setCaptureState] = useState<'camera' | 'preview' | 'analyzing' | 'results'>('camera'); // More specific type
//   const [capturedImage, setCapturedImage] = useState<ImagePickerAsset | null>(null); // Type: Image asset or null
//   const [recognizedFood, setRecognizedFood] = useState<FoodItem[] | null>(null); // Type: Array of FoodItem or null
//   const [isLoading, setIsLoading] = useState<boolean>(false); // Type: boolean
//   const [analysisProgress, setAnalysisProgress] = useState<number>(0); // Type: number (progress bar value 0-1)

//   // --- EFFECTS ---
//   // Request permissions on mount
//   useEffect(() => {
//     (async () => {
//       if (Platform.OS !== 'web') {
//         const { status } = await ImagePicker.requestCameraPermissionsAsync();
//         setHasPermission(status === 'granted');
//       } else {
//         console.warn("Camera functionality is not supported on web using expo-image-picker's launchCameraAsync.");
//         setHasPermission(false); // Explicitly set to false on web
//       }
//     })();
//   }, []);

//   // Simulate progress bar animation during analysis
//   useEffect(() => {
//     let interval: NodeJS.Timeout | null = null; // Store interval ID
//     if (captureState === 'analyzing') {
//       setAnalysisProgress(0); // Reset progress
//       interval = setInterval(() => {
//         setAnalysisProgress(prev => {
//           // Simulate progress, stopping just before 100%
//           const newProgress = prev + 0.01;
//           // Stop at 0.9 to let the API call completion finish the bar if needed
//           return newProgress >= 0.9 ? 0.9 : newProgress;
//         });
//       }, 50); // Faster interval for smoother look

//       // Cleanup function to clear interval if component unmounts or state changes
//       return () => {
//         if (interval) {
//           clearInterval(interval);
//         }
//       };
//     } else {
//         // Reset progress if not analyzing (optional, but good practice)
//         setAnalysisProgress(0);
//     }
//     // Need cleanup function if component unmounts while interval running
//     return () => {
//         if (interval) {
//             clearInterval(interval);
//         }
//     }
//   }, [captureState]); // Re-run effect when captureState changes

//   // --- FUNCTIONS ---
//   const takePicture = async () => {
//     try {
//       // Re-check permission just in case it changed
//       const permissionResult = await ImagePicker.requestCameraPermissionsAsync();
//       if (permissionResult.status !== 'granted') {
//         Alert.alert('Permission Required', 'Camera access is needed to take a photo.');
//         setHasPermission(false); // Update state if permission denied now
//         return;
//       }

//       const result = await ImagePicker.launchCameraAsync({
//         quality: 0.5, // Keep quality reasonable for upload size
//         base64: false, // Base64 usually not needed for uploads
//         allowsEditing: false, // Usually disable editing for scans
//       });

//       if (!result.canceled && result.assets && result.assets.length > 0) {
//         setCapturedImage(result.assets[0]); // result.assets is the correct structure now
//         setCaptureState('preview');
//         setRecognizedFood(null); // Clear previous results
//       } else {
//         console.log("Camera launch cancelled or failed to get assets.");
//       }
//     } catch (error: unknown) {
//       let message = 'Unable to access camera.';
//       if (error instanceof Error) {
//         message = error.message;
//       }
//       console.error('Camera error:', error);
//       Alert.alert('Camera Error', message);
//     }
//   };

//   const handleRetake = useCallback(() => { // Use useCallback if passed down, otherwise not strictly needed
//     console.log("Retake action");
//     setCaptureState('camera');
//     setCapturedImage(null);
//     setRecognizedFood(null);
//     setAnalysisProgress(0); // Reset progress too
//   }, []); // No dependencies needed here if only setting state

// // --- START OF PART 2 of 3 ---

// const handleAnalyze = async () => {
//   // Type guard to ensure capturedImage and its uri exist
//   if (!capturedImage?.uri) {
//       Alert.alert('Error', 'No image captured to analyze.');
//       console.error('handleAnalyze called without a valid capturedImage.uri');
//       setCaptureState('preview'); // Go back to preview if image somehow invalid
//       return;
//   }

//   console.log("Analyze action");
//   setCaptureState('analyzing');
//   setIsLoading(true); // Also set loading true

//   try {
//     // Construct file object for FormData
//     const file = {
//       uri: capturedImage.uri,
//       type: 'image/jpeg', // Or determine mime type dynamically if needed/possible
//       name: `scan_${Date.now()}.jpg`, // Create a unique name
//     };

//     const formData = new FormData();
//     // Use 'as any' for practical file upload typing in RN FormData
//     formData.append('file', file as any);

//     console.log("📤 Sending request to:", "https://test-fast-api-omega.vercel.app/upload/");
//     console.log("📦 FormData contents:", { uri: file.uri, type: file.type, name: file.name }); // Log cleanly

//     const uploadResponse = await axios.post<{ json: FoodItem[] }>( // Add expected response type
//       "https://test-fast-api-omega.vercel.app/upload/",
//       formData,
//       {
//         headers: {
//           'Content-Type': 'multipart/form-data',
//         },
//         // Optional: Add timeout
//         // timeout: 30000, // 30 seconds
//       }
//     );

//     console.log("✅ Response status:", uploadResponse.status);
//     // console.log("📨 Headers:", uploadResponse.headers); // Usually too verbose
//     console.log("📡 Response data:", uploadResponse.data);

//     // Check if the expected 'json' property with an array exists
//     const resultData = uploadResponse.data;
//     if (resultData && Array.isArray(resultData.json)) {
//       setAnalysisProgress(1); // Set progress to 100% on success
//       setRecognizedFood(resultData.json); // Set the typed array
//       setCaptureState('results');
//     } else {
//       // Handle cases where API response format is wrong
//       console.error('Invalid API response format:', resultData);
//       throw new Error('Received invalid data format from server.');
//     }
//   } catch (error: unknown) { // Type error as unknown
//     setAnalysisProgress(0); // Reset progress on error
//     let errorMessage = 'An unknown upload error occurred';
//     // Check if it's an Axios error first
//     if (axios.isAxiosError(error)) {
//        console.error("❌ Axios Upload error:", {
//           message: error.message,
//           code: error.code,
//           response: error.response ? { status: error.response.status, data: error.response.data } : "No response",
//           request: error.request ? "Request made" : "No request",
//        });
//        // Try to get a more specific message from API response if available
//        const apiErrorDetail = typeof error.response?.data?.detail === 'string' ? error.response.data.detail : null;
//        errorMessage = apiErrorDetail || error.message || `Upload failed (Status: ${error.response?.status ?? 'N/A'})`;
//     } else if (error instanceof Error) { // Check for generic Error
//         console.error("❌ Generic Upload error:", error.message, error.stack);
//         errorMessage = error.message;
//     } else {
//         // Handle cases where it's not an Error object
//         console.error("❌ Unexpected Upload error object:", error);
//     }
//     Alert.alert('Analysis Failed', errorMessage);
//     setCaptureState('preview'); // Go back to preview on failure
//   } finally {
//     setIsLoading(false); // Ensure loading is stopped
//   }
// };

// const handleAddToFoodLog = async () => {
//   console.log("Add to log action");
//   try {
//     // Type guard for recognizedFood array
//     if (!recognizedFood || recognizedFood.length === 0) {
//       Alert.alert('No Foods', 'No recognized foods available to add!');
//       return;
//     }

//     const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
//     const storedMealsJSON = await AsyncStorage.getItem('todayMeals');
//     // Parse safely, provide default empty array if null or invalid JSON
//     let todayMeals: any[] = []; // Start with generic array type
//      try {
//          if (storedMealsJSON) {
//               todayMeals = JSON.parse(storedMealsJSON);
//               if (!Array.isArray(todayMeals)) { // Ensure it's actually an array
//                   console.warn('Stored meals was not an array, resetting.');
//                   todayMeals = [];
//               }
//          }
//      } catch (parseError) {
//          console.error('Failed to parse stored meals:', parseError);
//          todayMeals = []; // Reset if parsing fails
//      }

//     // Define the structure of a meal for type safety (adapt if needed)
//     interface Meal {
//       id: string;
//       name: string;
//       time: string;
//       foods: FoodItem[]; // Use the FoodItem interface
//     }

//     // Create the new meal object
//     const newMeal: Meal = {
//       id: `scan-${Date.now()}`,
//       name: 'Food Scan', // Or perhaps use the primary food name? e.g., recognizedFood[0]?.name
//       time,
//       foods: recognizedFood.map((food: FoodItem) => ({ // food is type FoodItem from API
//         // Create an object matching the FoodItem interface for the Meal.foods array
//         name: food.name,
//         kcal: food.kcal,    // <<< Use kcal property name
//         protein: food.protein,
//         carbs: food.carbs,
//         fats: food.fats,      // <<< Use fats property name
//         // Remove 'id' and 'quantity' as they are not part of the FoodItem interface
//       })),
//     };

//     todayMeals.push(newMeal);
//     await AsyncStorage.setItem('todayMeals', JSON.stringify(todayMeals));

//     // Optional chaining for safety when accessing parent navigator
//     navigation.getParent()?.setParams({ mealsUpdated: Date.now() });

//     Alert.alert('Success', 'Food added to your log!');

//     // Use Expo Router to navigate
//     router.push('/(tabs)/home'); // Navigate to home tab

//   } catch (error: unknown) { // Type error as unknown
//       let logErrorMessage = 'Could not save food log.';
//       if (error instanceof Error) {
//           logErrorMessage = error.message;
//       }
//       console.error('Log error:', error); // Log the original error object too
//       Alert.alert('Error', logErrorMessage);
//   }
// };

// // Calculate totals - types should be inferred correctly now if recognizedFood is typed
// const calculateTotalNutrition = (foods: FoodItem[]) => { // Add type annotation for input
//   // Explicitly type the accumulator 'totals'
//   return foods.reduce(
//     (totals: { calories: number; protein: number; carbs: number; fat: number }, f: FoodItem) => ({
//       calories: totals.calories + (f.kcal || 0),
//       protein: totals.protein + (f.protein || 0),
//       carbs: totals.carbs + (f.carbs || 0),
//       fat: totals.fat + (f.fats || 0), // Use 'fats' based on interface
//     }),
//     // Initial value for the accumulator
//     { calories: 0, protein: 0, carbs: 0, fat: 0 }
//   );
// };

// // --- RENDER LOGIC HELPER ---
// // (Moved renderStateIndicator here - can be defined before use)
// const renderStateIndicator = () => {
//  // This component purely visualizes state, no changes needed for TypeScript here
//  // unless you want to type its props if it were extracted
//  return (
//    <View style={styles.stateIndicator}>
//      {/* ... JSX remains the same ... */}
//      <Text style={styles.stateTitle}>Screen State:</Text>
//       <View style={styles.stateTabs}>
//         <TouchableOpacity
//           style={[styles.stateTab, captureState === 'camera' && styles.activeStateTab]}
//           disabled={true}
//         >
//           <Text style={[styles.stateTabText, captureState === 'camera' && styles.activeStateTabText]}>Camera</Text>
//         </TouchableOpacity>
//         <TouchableOpacity
//           style={[styles.stateTab, captureState === 'preview' && styles.activeStateTab]}
//           disabled={true}
//         >
//           <Text style={[styles.stateTabText, captureState === 'preview' && styles.activeStateTabText]}>Preview</Text>
//         </TouchableOpacity>
//         <TouchableOpacity
//           style={[styles.stateTab, captureState === 'analyzing' && styles.activeStateTab]}
//           disabled={true}
//         >
//           <Text style={[styles.stateTabText, captureState === 'analyzing' && styles.activeStateTabText]}>Analyzing</Text>
//         </TouchableOpacity>
//         <TouchableOpacity
//           style={[styles.stateTab, captureState === 'results' && styles.activeStateTab]}
//           disabled={true}
//         >
//           <Text style={[styles.stateTabText, captureState === 'results' && styles.activeStateTabText]}>Results</Text>
//         </TouchableOpacity>
//       </View>
//    </View>
//  );
// };

// // --- START OF PART 3 of 3 ---

//   // --- RENDER LOGIC ---

//   // Loading Permissions State
//   if (hasPermission === null) {
//     return (
//       <SafeAreaView style={styles.safeArea}>
//         {renderStateIndicator()}
//         <View style={styles.loaderContainer}>
//           <ActivityIndicator size="large" color="#3b82f6" />
//           <Text style={styles.loaderText}>Requesting camera permissions...</Text>
//         </View>
//       </SafeAreaView>
//     );
//   }

//   // Permission Denied State
//   if (hasPermission === false) {
//     return (
//       <SafeAreaView style={styles.safeArea}>
//         {renderStateIndicator()}
//         <View style={styles.container}>
//           <Ionicons name="alert-circle-outline" size={40} color="#ef4444" style={{ marginBottom: 10 }}/>
//           <Text style={styles.errorText}>Camera Permission Required</Text>
//           <Text style={styles.errorSubText}>Please grant camera permission in your device settings to use the scanner.</Text>
//           <TouchableOpacity style={styles.button} onPress={() => navigation.goBack()}>
//             <Text style={styles.buttonText}>Go Back</Text>
//           </TouchableOpacity>
//           {/* You could add a button to open settings using Linking API */}
//         </View>
//       </SafeAreaView>
//     );
//   }

//   // State: Camera (Initial state to trigger camera launch)
//   if (captureState === 'camera') {
//     return (
//       <SafeAreaView style={styles.safeArea}>
//         {renderStateIndicator()}
//         {/* This state doesn't show live preview, it shows a button to launch the external camera */}
//         <View style={styles.cameraContainer}>
//           <TouchableOpacity style={styles.backButton} onPress={() => navigation.goBack()}>
//             <Ionicons name="arrow-back" size={24} color="#374151" />
//           </TouchableOpacity>

//           <View style={styles.cameraInstructionContent}>
//              <Ionicons name="camera-outline" size={80} color="#3b82f6" style={{ marginBottom: 20 }}/>
//              <Text style={styles.cameraTitle}>Scan Food Item</Text>
//              <Text style={styles.cameraSubtitle}>Press the button below to open the camera and take a photo of your food.</Text>

//              <TouchableOpacity style={styles.bigLaunchButton} onPress={takePicture}>
//                <Ionicons name="camera" size={22} color="#fff" style={{ marginRight: 10 }} />
//                <Text style={styles.bigLaunchButtonText}>Launch Camera</Text>
//              </TouchableOpacity>
//           </View>
//         </View>
//       </SafeAreaView>
//     );
//   }

//   // State: Preview Image
//   // Add type guard: only render if capturedImage exists
//   if (captureState === 'preview' && capturedImage) {
//     return (
//       <SafeAreaView style={styles.safeArea}>
//         {renderStateIndicator()}
//         <View style={styles.previewContainer}>
//           <View style={styles.previewHeader}>
//             <TouchableOpacity onPress={handleRetake}>
//               <Ionicons name="close" size={28} color="#374151" />
//             </TouchableOpacity>
//             <Text style={styles.previewTitle}>Image Preview</Text>
//             <View style={{ width: 28 }} /> {/* Spacer */}
//           </View>

//           {/* Image requires capturedImage to exist */}
//           <Image source={{ uri: capturedImage.uri }} style={styles.previewImage} resizeMode="contain"/>

//           <View style={styles.previewControls}>
//             <TouchableOpacity style={styles.retakeButton} onPress={handleRetake} disabled={isLoading}>
//               <Ionicons name="refresh" size={20} color="#374151" />
//               <Text style={styles.retakeButtonText}>Retake</Text>
//             </TouchableOpacity>

//             <TouchableOpacity style={styles.analyzeButton} onPress={handleAnalyze} disabled={isLoading}>
//                {isLoading ? (
//                    <ActivityIndicator size="small" color="white" style={{ marginRight: 8 }} />
//                ) : (
//                    <Ionicons name="scan" size={20} color="white" style={{ marginRight: 8 }} />
//                )}
//               <Text style={styles.analyzeButtonText}>{isLoading ? 'Analyzing...' : 'Analyze'}</Text>
//             </TouchableOpacity>
//           </View>
//         </View>
//       </SafeAreaView>
//     );
//   }

//   // State: Analyzing
//   if (captureState === 'analyzing') {
//     return (
//       <SafeAreaView style={styles.safeArea}>
//         {renderStateIndicator()}
//         <View style={styles.analyzingContainer}>
//           <View style={styles.analyzingContent}>
//             <View style={styles.loaderCircle}>
//               <ActivityIndicator size="large" color="#3b82f6" />
//             </View>

//             <Text style={styles.analyzingTitle}>Analyzing your food</Text>
//             <Text style={styles.analyzingSubtitle}>
//               Our AI is identifying ingredients and calculating nutritional information...
//             </Text>

//             <View style={styles.progressBarContainer}>
//               <View style={[styles.progressBar, { width: `${analysisProgress * 100}%` }]} />
//             </View>

//             {/* Optional: Show estimated time or different messages based on progress */}
//             {/* <Text style={styles.analyzingTimeEstimate}>This might take a moment...</Text> */}
//           </View>
//         </View>
//       </SafeAreaView>
//     );
//   }

//   // State: Results
//   // Add type guard: only render if recognizedFood array exists and has items
//   if (captureState === 'results' && recognizedFood && recognizedFood.length > 0) {
//     const total = calculateTotalNutrition(recognizedFood); // Pass the typed array
//     // Example confidence - replace with actual data if available
//     const matchPercentage = `${recognizedFood[0]?.kcal > 100 ? 92 : 85}%`; // Dummy logic

//     return (
//       <SafeAreaView style={styles.safeArea}>
//         {renderStateIndicator()}
//         <View style={styles.resultsContainer}>
//            {/* Header */}
//           <View style={styles.resultsHeader}>
//             <TouchableOpacity onPress={handleRetake} style={styles.backButton}>
//                 <Ionicons name="arrow-back" size={24} color="white" />
//             </TouchableOpacity>
//             <Text style={styles.resultsTitle}>Analysis Results</Text>
//              {/* Spacer to center title */}
//             <View style={{ width: 24 }}/>
//           </View>

//           <ScrollView style={styles.resultsScrollView}>
//             {/* Result Card */}
//             <View style={styles.resultsCard}>
//               {/* Image requires capturedImage to exist */}
//               {capturedImage && <Image source={{ uri: capturedImage.uri }} style={styles.resultImage} resizeMode="cover" />}

//               <View style={styles.foodMatched}>
//                 <Text style={styles.foodMatchedName}>
//                   {/* Use primary food name, provide fallback */}
//                   {recognizedFood[0]?.name || "Identified Food"}
//                 </Text>
//                 <View style={styles.matchBadge}>
//                   <Text style={styles.matchText}>{matchPercentage} match</Text>
//                 </View>
//               </View>

//               <View style={styles.nutritionSummary}>
//                 <Text style={styles.nutritionLabel}>Total Estimated Calories</Text>
//                 <Text style={styles.caloriesValue}>{Math.round(total.calories)} kcal</Text>

//                 <View style={styles.macrosRow}>
//                   <View style={styles.macroItem}>
//                     <Text style={styles.macroLabel}>Protein</Text>
//                     <Text style={styles.macroValue}>{total.protein.toFixed(1)}g</Text>
//                   </View>
//                   <View style={styles.macroItem}>
//                     <Text style={styles.macroLabel}>Carbs</Text>
//                     <Text style={styles.macroValue}>{total.carbs.toFixed(1)}g</Text>
//                   </View>
//                   <View style={styles.macroItem}>
//                     <Text style={styles.macroLabel}>Fat</Text>
//                     <Text style={styles.macroValue}>{total.fat.toFixed(1)}g</Text>
//                   </View>
//                 </View>
//               </View>
//             </View>

//             {/* Identified Items List */}
//             <View style={styles.identifiedItemsContainer}>
//               <Text style={styles.identifiedItemsTitle}>Identified Items Breakdown</Text>

//               {recognizedFood.map((food: FoodItem, idx: number) => ( // Explicit types for map params
//                 <View key={`${food.name}-${idx}`} style={styles.identifiedItem}>
//                   <View style={styles.itemDetail}>
//                     <Text style={styles.itemName}>{food.name}</Text>
//                     {/* Example portion logic - replace with real data if available */}
//                     {/* <Text style={styles.itemPortion}>Approx. 1 serving</Text> */}
//                   </View>
//                   <Text style={styles.itemCalories}>{food.kcal} cal</Text>
//                 </View>
//               ))}
//             </View>

//             <Text style={styles.disclaimerText}>
//               Nutritional information is estimated based on image recognition. Verify for accuracy.
//             </Text>
//           </ScrollView>

//           {/* Add to Log Button */}
//           <TouchableOpacity style={styles.addToLogButton} onPress={handleAddToFoodLog}>
//             <Ionicons name="add-circle-outline" size={22} color="white" />
//             <Text style={styles.addToLogButtonText}>Add Items to Log</Text>
//           </TouchableOpacity>
//         </View>
//       </SafeAreaView>
//     );
//   }

//   // Fallback for unexpected states or if results array is empty
//    if (captureState === 'results' && (!recognizedFood || recognizedFood.length === 0)) {
//      return (
//        <SafeAreaView style={styles.safeArea}>
//          {renderStateIndicator()}
//          <View style={styles.container}>
//             <Ionicons name="sad-outline" size={40} color="#f97316" style={{ marginBottom: 10 }}/>
//             <Text style={styles.errorText}>Analysis Complete</Text>
//             <Text style={styles.errorSubText}>Could not identify food items in the image.</Text>
//             <TouchableOpacity style={styles.button} onPress={handleRetake}>
//               <Text style={styles.buttonText}>Try Again</Text>
//             </TouchableOpacity>
//          </View>
//        </SafeAreaView>
//      );
//    }


//   // General Fallback for any other unexpected state
//   return (
//     <SafeAreaView style={styles.safeArea}>
//       {renderStateIndicator()}
//       <View style={styles.container}>
//         <Text style={styles.errorText}>An unexpected error occurred.</Text>
//          <TouchableOpacity style={styles.button} onPress={handleRetake}>
//             <Text style={styles.buttonText}>Start Over</Text>
//          </TouchableOpacity>
//       </View>
//     </SafeAreaView>
//   );
// } // End of component

// // --- STYLES ---
// // (Using Dimensions requires it to be defined outside the component scope)
// const { width } = Dimensions.get('window');

// const styles = StyleSheet.create({
//   safeArea: {
//     flex: 1,
//     backgroundColor: '#f8fafc', // Light grey background
//     paddingTop: Platform.OS === 'android' ? StatusBar.currentHeight : 0,
//   },
//   // State indicator styles
//   stateIndicator: {
//     backgroundColor: '#ffffff', // White background for indicator bar
//     paddingVertical: 8,
//     paddingHorizontal: 16,
//     borderBottomWidth: 1,
//     borderBottomColor: '#e2e8f0', // Light border
//   },
//   stateTitle: {
//     fontSize: 12, // Smaller title
//     fontWeight: '600', // Semibold
//     color: '#64748b', // Muted color
//     marginBottom: 6,
//     textTransform: 'uppercase',
//     letterSpacing: 0.5,
//   },
//   stateTabs: {
//     flexDirection: 'row',
//     justifyContent: 'space-around', // Space out tabs
//   },
//   stateTab: {
//     paddingVertical: 6,
//     paddingHorizontal: 10,
//     borderRadius: 15, // Pill shape
//     borderWidth: 1,
//     borderColor: 'transparent', // No border by default
//   },
//   activeStateTab: {
//     backgroundColor: '#e0f2fe', // Light blue background for active
//     borderColor: '#7dd3fc', // Blue border for active
//   },
//   stateTabText: {
//     fontSize: 13,
//     color: '#475569', // Darker muted text
//     fontWeight: '500',
//   },
//   activeStateTabText: {
//     color: '#0c4a6e', // Dark blue text for active
//     fontWeight: '600',
//   },

//   // Camera screen styles (instructional state)
//   cameraContainer: {
//     flex: 1,
//     backgroundColor: '#f8fafc', // Match safe area background
//     alignItems: 'center', // Center content vertically
//     justifyContent: 'center', // Center content horizontally
//     padding: 20,
//   },
//    cameraInstructionContent: {
//      alignItems: 'center',
//      maxWidth: 350,
//    },
//    backButton: { // General back button style
//     position: 'absolute',
//     top: 16,
//     left: 16,
//     zIndex: 10,
//     padding: 5, // Add padding for easier tap target
//   },
//   cameraTitle: { // Title for camera instruction screen
//     fontSize: 24,
//     fontWeight: 'bold',
//     color: '#1e293b', // Dark text
//     textAlign: 'center',
//     marginBottom: 8,
//   },
//   cameraSubtitle: { // Subtitle for camera instruction screen
//     fontSize: 16,
//     color: '#64748b', // Muted color
//     textAlign: 'center',
//     marginBottom: 40,
//     lineHeight: 24,
//   },
//   bigLaunchButton: { // Button to launch external camera
//     backgroundColor: '#3b82f6', // Blue
//     paddingVertical: 16,
//     paddingHorizontal: 30,
//     borderRadius: 30, // Rounded pill shape
//     flexDirection: 'row',
//     alignItems: 'center',
//     justifyContent: 'center',
//     shadowColor: '#000',
//     shadowOffset: { width: 0, height: 2 },
//     shadowOpacity: 0.15,
//     shadowRadius: 4,
//     elevation: 3,
//   },
//   bigLaunchButtonText: {
//     color: '#fff',
//     fontSize: 18,
//     fontWeight: '600', // Semibold
//   },


//   // Preview screen styles
//   previewContainer: {
//     flex: 1,
//     backgroundColor: '#f8fafc', // Light background
//   },
//   previewHeader: {
//     flexDirection: 'row',
//     justifyContent: 'space-between',
//     alignItems: 'center',
//     paddingVertical: 12,
//     paddingHorizontal: 16,
//     borderBottomWidth: 1,
//     borderBottomColor: '#e2e8f0',
//     backgroundColor: '#ffffff', // White header background
//   },
//   previewTitle: {
//     fontSize: 18,
//     fontWeight: '600', // Semibold
//     color: '#1e293b',
//   },
//   previewImage: {
//     flex: 1, // Take available space
//     margin: 16,
//     borderRadius: 12,
//     backgroundColor: '#e2e8f0', // Placeholder bg
//   },
//   previewControls: {
//     flexDirection: 'row',
//     justifyContent: 'space-between',
//     padding: 16,
//     borderTopWidth: 1,
//     borderTopColor: '#e2e8f0',
//     backgroundColor: '#ffffff', // White controls background
//   },
//   retakeButton: { // Consistent button style
//     flexDirection: 'row',
//     alignItems: 'center',
//     backgroundColor: '#ffffff', // White background
//     paddingVertical: 12,
//     paddingHorizontal: 20,
//     borderRadius: 8,
//     borderWidth: 1,
//     borderColor: '#cbd5e1', // Gray border
//     shadowColor: '#000',
//     shadowOffset: { width: 0, height: 1 },
//     shadowOpacity: 0.05,
//     shadowRadius: 2,
//     elevation: 1,
//   },
//   retakeButtonText: {
//     color: '#374151', // Dark gray text
//     marginLeft: 8,
//     fontWeight: '600',
//     fontSize: 16,
//   },
//   analyzeButton: { // Consistent button style
//     flexDirection: 'row',
//     alignItems: 'center',
//     backgroundColor: '#3b82f6', // Blue background
//     paddingVertical: 12,
//     paddingHorizontal: 20,
//     borderRadius: 8,
//     shadowColor: '#000',
//     shadowOffset: { width: 0, height: 2 },
//     shadowOpacity: 0.15,
//     shadowRadius: 4,
//     elevation: 3,
//   },
//   analyzeButtonText: {
//     color: 'white',
//     // marginRight: 8, // Icon now on left
//     fontWeight: '600',
//     fontSize: 16,
//   },

//   // Analyzing screen styles
//   analyzingContainer: {
//     flex: 1,
//     backgroundColor: '#f8fafc', // Light background
//     padding: 20,
//     justifyContent: 'center',
//     alignItems: 'center', // Center the content box
//   },
//   analyzingContent: {
//     backgroundColor: 'white',
//     borderRadius: 16,
//     padding: 30, // More padding
//     alignItems: 'center',
//     shadowColor: '#000',
//     shadowOffset: { width: 0, height: 4 }, // More shadow
//     shadowOpacity: 0.1,
//     shadowRadius: 10,
//     elevation: 5,
//     width: '90%', // Limit width
//     maxWidth: 400,
//   },
//   loaderCircle: {
//     width: 72, // Larger circle
//     height: 72,
//     borderRadius: 36,
//     backgroundColor: '#e0f2fe', // Lighter blue
//     justifyContent: 'center',
//     alignItems: 'center',
//     marginBottom: 24,
//   },
//   analyzingTitle: {
//     fontSize: 22, // Larger title
//     fontWeight: 'bold',
//     textAlign: 'center',
//     marginBottom: 12,
//     color: '#1e293b',
//   },
//   analyzingSubtitle: {
//     fontSize: 15, // Slightly larger subtitle
//     textAlign: 'center',
//     color: '#64748b',
//     marginBottom: 30, // More margin
//     lineHeight: 22,
//   },
//   progressBarContainer: {
//     width: '100%',
//     height: 10, // Thicker bar
//     backgroundColor: '#e2e8f0',
//     borderRadius: 5,
//     overflow: 'hidden',
//     marginBottom: 20, // More margin
//   },
//   progressBar: {
//     height: '100%',
//     backgroundColor: '#3b82f6', // Blue progress
//     borderRadius: 5,
//   },
//   analyzingTimeEstimate: { // Removed in render, keep style if needed later
//     fontSize: 14,
//     color: '#94a3b8',
//   },

//   // Results screen styles
//   resultsContainer: {
//     flex: 1,
//     backgroundColor: '#f8fafc', // Match safe area background
//   },
//   resultsHeader: {
//     backgroundColor: '#3b82f6', // Blue header
//     paddingVertical: 12, // Adjusted padding
//     paddingHorizontal: 16,
//     flexDirection: 'row',
//     alignItems: 'center',
//     justifyContent: 'space-between', // Space out items
//   },
//   resultsTitle: {
//     color: 'white',
//     fontSize: 20, // Slightly larger title
//     fontWeight: 'bold',
//     textAlign: 'center', // Center title if needed (adjust layout)
//      flex: 1, // Allow title to take space for centering between buttons
//   },
//   resultsScrollView: {
//     flex: 1,
//   },
//   resultsCard: {
//     backgroundColor: 'white',
//     margin: 16,
//     borderRadius: 12,
//     overflow: 'hidden', // Clip image corners
//     shadowColor: '#9ca3af', // Muted shadow color
//     shadowOffset: { width: 0, height: 3 },
//     shadowOpacity: 0.2,
//     shadowRadius: 5,
//     elevation: 4,
//   },
//   resultImage: {
//     width: '100%',
//     height: 220, // Larger image
//     backgroundColor: '#e2e8f0',
//   },
//   foodMatched: {
//     flexDirection: 'row',
//     justifyContent: 'space-between',
//     alignItems: 'center',
//     paddingVertical: 10,
//     paddingHorizontal: 16,
//     backgroundColor: '#f1f5f9', // Very light grey background
//     borderBottomWidth: 1,
//     borderBottomColor: '#e2e8f0',
//   },
//   foodMatchedName: {
//     color: '#1e293b', // Dark text
//     fontSize: 18, // Larger name
//     fontWeight: '600', // Semibold
//     flex: 1, // Allow text to wrap if long
//     marginRight: 10,
//   },
//   matchBadge: {
//     backgroundColor: '#16a34a', // Darker green
//     paddingVertical: 5,
//     paddingHorizontal: 10,
//     borderRadius: 15, // Pill shape
//   },
//   matchText: {
//     color: 'white',
//     fontSize: 12,
//     fontWeight: '600',
//   },
//   nutritionSummary: {
//     padding: 16,
//   },
//   nutritionLabel: {
//     fontSize: 14,
//     color: '#64748b', // Muted label color
//     marginBottom: 4,
//   },
//   caloriesValue: {
//     fontSize: 32, // Large calorie display
//     fontWeight: 'bold',
//     color: '#1e293b',
//     marginBottom: 16,
//   },
//   macrosRow: {
//     flexDirection: 'row',
//     justifyContent: 'space-between',
//     borderTopWidth: 1,
//     borderTopColor: '#f1f5f9', // Light separator
//     paddingTop: 16,
//   },
//   macroItem: {
//     alignItems: 'center',
//     flex: 1,
//   },
//   macroLabel: {
//     fontSize: 13, // Smaller label
//     color: '#64748b',
//     marginBottom: 4,
//     textTransform: 'uppercase',
//     letterSpacing: 0.5,
//   },
//   macroValue: {
//     fontSize: 18, // Larger macro value
//     fontWeight: '600',
//     color: '#334155', // Darker gray
//   },
//   identifiedItemsContainer: {
//     backgroundColor: 'white',
//     marginHorizontal: 16,
//     marginBottom: 16,
//     borderRadius: 12,
//     overflow: 'hidden',
//     shadowColor: '#9ca3af',
//     shadowOffset: { width: 0, height: 2 },
//     shadowOpacity: 0.15,
//     shadowRadius: 4,
//     elevation: 3,
//   },
//   identifiedItemsTitle: {
//     fontSize: 16,
//     fontWeight: '600',
//     color: '#1e293b',
//     padding: 16,
//     borderBottomWidth: 1,
//     borderBottomColor: '#f1f5f9',
//   },
//   identifiedItem: {
//     flexDirection: 'row',
//     justifyContent: 'space-between',
//     alignItems: 'center',
//     paddingVertical: 14, // More padding
//     paddingHorizontal: 16,
//     borderTopWidth: 1,
//     borderTopColor: '#f1f5f9', // Very light separator
//   },
//   itemDetail: {
//     flex: 1, // Allow text to take space
//     marginRight: 10,
//   },
//   itemName: {
//     fontSize: 15,
//     fontWeight: '500',
//     color: '#334155',
//   },
//   itemPortion: { // Style for portion text if you add it
//     fontSize: 13,
//     color: '#64748b',
//     marginTop: 2,
//   },
//   itemCalories: {
//     fontSize: 15,
//     fontWeight: '600', // Bolder calories
//     color: '#0ea5e9', // Blueish color for calories
//   },
//   disclaimerText: {
//     fontSize: 12,
//     color: '#64748b', // Muted color
//     textAlign: 'center',
//     marginHorizontal: 24, // More horizontal margin
//     marginBottom: 24,
//     lineHeight: 18,
//   },
//   addToLogButton: { // Add to log button style
//     backgroundColor: '#16a34a', // Green color
//     marginHorizontal: 16,
//     marginBottom: Platform.OS === 'ios' ? 25 : 16, // More bottom margin on iOS
//     marginTop: 8, // Add some space above
//     borderRadius: 8,
//     flexDirection: 'row',
//     justifyContent: 'center',
//     alignItems: 'center',
//     paddingVertical: 16, // Taller button
//     shadowColor: '#000',
//     shadowOffset: { width: 0, height: 2 },
//     shadowOpacity: 0.2,
//     shadowRadius: 4,
//     elevation: 4,
//   },
//   addToLogButtonText: {
//     color: 'white',
//     fontWeight: '600',
//     fontSize: 16,
//     marginLeft: 10,
//   },

//   // General/Fallback styles
//   container: {
//     flex: 1,
//     justifyContent: 'center',
//     alignItems: 'center',
//     padding: 20,
//     backgroundColor: '#f8fafc',
//   },
//   loaderContainer: {
//     flex: 1,
//     justifyContent: 'center',
//     alignItems: 'center',
//     backgroundColor: '#f8fafc', // Match background
//   },
//   loaderText: {
//     marginTop: 15, // More space
//     color: '#64748b',
//     fontSize: 16, // Larger text
//   },
//   errorText: { // For permission denied / fallback
//     fontSize: 18, // Larger text
//     fontWeight: '600', // Semibold
//     color: '#334155', // Darker text
//     textAlign: 'center',
//     marginBottom: 10,
//   },
//   errorSubText: { // Subtext for errors
//       fontSize: 14,
//       color: '#64748b',
//       textAlign: 'center',
//       marginBottom: 25,
//       lineHeight: 20,
//       paddingHorizontal: 10,
//   },
//   button: { // General purpose button (e.g., Go Back)
//     backgroundColor: '#3b82f6',
//     paddingVertical: 12,
//     paddingHorizontal: 24,
//     borderRadius: 8,
//   },
//   buttonText: { // Text for general button
//     color: 'white',
//     fontWeight: '600',
//     fontSize: 16,
//   },
// });

------------------------

/common\ErrorFallBackView.tsx :

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';
import { Ionicons } from '@expo/vector-icons';

interface ErrorFallbackViewProps {
    message: string;
    onRetry: () => void;
    retryLabel?: string;
}

export const ErrorFallbackView: React.FC<ErrorFallbackViewProps> = ({ message, onRetry, retryLabel = "Start Over" }) => (
     <View style={styles.container}>
        <Ionicons name="warning-outline" size={40} color="#f97316" style={{ marginBottom: 10 }}/>
        <Text style={styles.errorText}>{message}</Text>
        <TouchableOpacity style={styles.button} onPress={onRetry}>
            <Text style={styles.buttonText}>{retryLabel}</Text>
         </TouchableOpacity>
     </View>
);

const styles = StyleSheet.create({
     container: { flex: 1, justifyContent: 'center', alignItems: 'center', padding: 20, backgroundColor: '#f8fafc' },
     errorText: { fontSize: 16, color: '#334155', textAlign: 'center', marginBottom: 25, lineHeight: 22 },
     button: { backgroundColor: '#3b82f6', paddingVertical: 12, paddingHorizontal: 24, borderRadius: 8 },
     buttonText: { color: 'white', fontWeight: '600', fontSize: 16 },
});

------------------------

/common\PermisionDeniedView.tsx :

// components/common/PermissionDeniedView.tsx
import React from 'react';
import { View, Text, TouchableOpacity, Button, StyleSheet } from 'react-native';
import { Ionicons } from '@expo/vector-icons';

interface PermissionDeniedViewProps {
    onGrantPermission: () => void;
    onGoBack: () => void;
}

export const PermissionDeniedView: React.FC<PermissionDeniedViewProps> = ({ onGrantPermission, onGoBack }) => (
    <View style={styles.container}>
        <Ionicons name="alert-circle-outline" size={40} color="#ef4444" style={{ marginBottom: 10 }}/>
        <Text style={styles.errorText}>Camera Permission Required</Text>
        <Text style={styles.errorSubText}>Please grant camera permission in your device settings or press below.</Text>
        {/* Button from react-native requires onPress and title */}
        <View style={{marginBottom: 15}}>
             <Button onPress={onGrantPermission} title="Grant Permission"/>
        </View>
        <TouchableOpacity style={styles.button} onPress={onGoBack}>
            <Text style={styles.buttonText}>Go Back</Text>
        </TouchableOpacity>
    </View>
);

const styles = StyleSheet.create({
    container: { flex: 1, justifyContent: 'center', alignItems: 'center', padding: 20, backgroundColor: '#f8fafc' },
    errorText: { fontSize: 18, fontWeight: '600', color: '#334155', textAlign: 'center', marginBottom: 10 },
    errorSubText: { fontSize: 14, color: '#64748b', textAlign: 'center', marginBottom: 25, lineHeight: 20, paddingHorizontal: 10 },
    button: { backgroundColor: '#64748b', paddingVertical: 12, paddingHorizontal: 24, borderRadius: 8 }, // Secondary color
    buttonText: { color: 'white', fontWeight: '600', fontSize: 16 },
});

------------------------

/common\PermissionLoadingView.tsx :

// components/common/PermissionLoadingView.tsx (or similar path)
import React from 'react';
import { View, Text, ActivityIndicator, StyleSheet } from 'react-native';

export const PermissionLoadingView = () => (
    <View style={styles.loaderContainer}>
        <ActivityIndicator size="large" color="#3b82f6" />
        <Text style={styles.loaderText}>Requesting Permissions...</Text>
    </View>
);

const styles = StyleSheet.create({
    loaderContainer: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#f8fafc' },
    loaderText: { marginTop: 15, color: '#64748b', fontSize: 16 },
});

------------------------

/foodScanner\CameraInstructionView.tsx :

// components/camera/CameraInstructionView.tsx
import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
// Import or define styles needed (e.g., from FoodScannerScreen styles)

interface CameraInstructionViewProps {
  onLaunchCamera: () => void;
}

export const CameraInstructionView: React.FC<CameraInstructionViewProps> = ({ onLaunchCamera }) => (
  <View style={styles.cameraInstructionContent}>
     <Ionicons name="camera-outline" size={80} color="#3b82f6" style={{ marginBottom: 20 }}/>
     <Text style={styles.cameraTitle}>Scan Food Item</Text>
     <Text style={styles.cameraSubtitle}>Press the button below to open the camera...</Text>
     <TouchableOpacity style={styles.bigLaunchButton} onPress={onLaunchCamera}>
       <Ionicons name="camera" size={22} color="#fff" style={{ marginRight: 10 }} />
       <Text style={styles.bigLaunchButtonText}>Launch Camera</Text>
     </TouchableOpacity>
  </View>
);
// Add relevant styles from FoodScannerScreen.styles here or import them
const styles = StyleSheet.create({ 
    cameraInstructionContent: {
        alignItems: 'center',
        maxWidth: 350,
      },
      cameraTitle: { // Title for camera instruction screen
        fontSize: 24,
        fontWeight: 'bold',
        color: '#1e293b', // Dark text
        textAlign: 'center',
        marginBottom: 8,
      },
      cameraSubtitle: { // Subtitle for camera instruction screen
        fontSize: 16,
        color: '#64748b', // Muted color
        textAlign: 'center',
        marginBottom: 40,
        lineHeight: 24,
      },
      bigLaunchButton: { // Button to launch external camera
        backgroundColor: '#3b82f6', // Blue
        paddingVertical: 16,
        paddingHorizontal: 30,
        borderRadius: 30, // Rounded pill shape
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'center',
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.15,
        shadowRadius: 4,
        elevation: 3,
      },
      bigLaunchButtonText: {
        color: '#fff',
        fontSize: 18,
        fontWeight: '600', // Semibold
      },
});

------------------------

/foodScanner\LoadingSpinner.tsx :

import React, { useState, useEffect, useRef } from 'react';
import { View, Text, Animated, Easing, StyleSheet } from 'react-native';
import Svg, { Path } from 'react-native-svg';

const LoadingSpinner: React.FC = () => {
  const [progress, setProgress] = useState<number>(0);
  const [analyzing, setAnalyzing] = useState<boolean>(true);
  
  // Animation values
  const spinValue = useRef(new Animated.Value(0)).current;
  const reverseSpinValue = useRef(new Animated.Value(0)).current;
  const pulseValue = useRef(new Animated.Value(0)).current;
  
  useEffect(() => {
    // Spin animation
    Animated.loop(
      Animated.timing(spinValue, {
        toValue: 1,
        duration: 2000,
        easing: Easing.linear,
        useNativeDriver: true,
      })
    ).start();
    
    // Reverse spin animation
    Animated.loop(
      Animated.timing(reverseSpinValue, {
        toValue: 1,
        duration: 2500,
        easing: Easing.linear,
        useNativeDriver: true,
      })
    ).start();
    
    // Pulse animation
    Animated.loop(
      Animated.sequence([
        Animated.timing(pulseValue, {
          toValue: 1,
          duration: 1000,
          easing: Easing.inOut(Easing.ease),
          useNativeDriver: true,
        }),
        Animated.timing(pulseValue, {
          toValue: 0.7,
          duration: 1000,
          easing: Easing.inOut(Easing.ease),
          useNativeDriver: true,
        })
      ])
    ).start();
    
    // Progress timer
    let timer: NodeJS.Timeout | undefined;
    if (analyzing) {
      timer = setInterval(() => {
        setProgress(prevProgress => {
          const newProgress = prevProgress + 1;
          if (newProgress >= 100) {
            if (timer) clearInterval(timer);
            setAnalyzing(false);
            return 100;
          }
          return newProgress;
        });
      }, 80);
    }
    
    return () => {
      if (timer) clearInterval(timer);
    };
  }, [analyzing, spinValue, reverseSpinValue, pulseValue]);
  
  // Spin interpolations
  const spin = spinValue.interpolate({
    inputRange: [0, 1],
    outputRange: ['0deg', '360deg']
  });
  
  const reverseSpin = reverseSpinValue.interpolate({
    inputRange: [0, 1],
    outputRange: ['360deg', '0deg']
  });
  
  const scale = pulseValue.interpolate({
    inputRange: [0.7, 1],
    outputRange: [0.9, 1]
  });
  
  return (
    <View style={styles.container}>
      <View style={styles.spinnerContainer}>
        {/* Outer spinning ring */}
        <Animated.View 
          style={[
            styles.outerRing, 
            { transform: [{ rotate: spin }] }
          ]} 
        />
        
        {/* Inner spinning ring - opposite direction */}
        <Animated.View 
          style={[
            styles.innerRing, 
            { transform: [{ rotate: reverseSpin }] }
          ]} 
        />
        
        {/* Center pulse */}
        <Animated.View 
          style={[
            styles.center,
            { transform: [{ scale }] }
          ]}
        >
          <Svg width={24} height={24} viewBox="0 0 20 20" fill="white">
            <Path d="M10 12a2 2 0 100-4 2 2 0 000 4z" />
            <Path 
              fillRule="evenodd" 
              d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" 
              clipRule="evenodd" 
            />
          </Svg>
        </Animated.View>
      </View>
      
      {/* Progress text */}
      <Text style={styles.statusText}>
        {analyzing ? "Analyzing Image..." : "Analysis Complete!"}
      </Text>
      
      {/* Progress bar */}
      <View style={styles.progressBarContainer}>
        <View 
          style={[
            styles.progressBar, 
            { width: `${progress}%` }
          ]} 
        />
      </View>
      
      {/* Progress percentage */}
      <Text style={styles.percentageText}>
        {progress}% {analyzing ? "processed" : "complete"}
      </Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#F9FAFB',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    padding: 10,
    width: '100%',
    alignSelf: 'center',
  },
  spinnerContainer: {
    width: 120,
    height: 120,
    marginBottom: 16,
    alignItems: 'center',
    justifyContent: 'center',
    position: 'relative',
  },
  outerRing: {
    position: 'absolute',
    width: '100%',
    height: '100%',
    borderRadius: 60,
    borderWidth: 4,
    borderTopColor: '#3B82F6', // blue-500
    borderRightColor: '#60A5FA', // blue-400
    borderBottomColor: '#93C5FD', // blue-300
    borderLeftColor: '#BFDBFE', // blue-200
  },
  innerRing: {
    position: 'absolute',
    width: '85%',
    height: '85%',
    borderRadius: 60,
    borderWidth: 4,
    borderTopColor: '#E9D5FF', // purple-200
    borderRightColor: '#D8B4FE', // purple-300
    borderBottomColor: '#C084FC', // purple-400
    borderLeftColor: '#A855F7', // purple-500
  },
  center: {
    position: 'absolute',
    width: '50%',
    height: '50%',
    borderRadius: 40,
    backgroundColor: '#818CF8', // indigo-400 to purple-500 gradient effect
    alignItems: 'center',
    justifyContent: 'center',
  },
  statusText: {
    fontSize: 18,
    fontWeight: '600',
    color: '#374151', // gray-700
    marginBottom: 8,
  },
  progressBarContainer: {
    width: '100%',
    height: 16,
    backgroundColor: '#E5E7EB', // gray-200
    borderRadius: 8,
    marginBottom: 8,
    overflow: 'hidden',
  },
  progressBar: {
    height: '100%',
    borderRadius: 8,
    backgroundColor: '#818CF8', // indigo-500
  },
  percentageText: {
    fontSize: 14,
    color: '#6B7280', // gray-500
  },
});

export default LoadingSpinner;

------------------------

/foodScanner\PreviewView.tsx :

// components/camera/PreviewView.tsx
import React from 'react';
import { View, Text, Image, TouchableOpacity, ActivityIndicator, StyleSheet } from 'react-native';
import { Ionicons } from '@expo/vector-icons';

interface PreviewViewProps {
    imageUri: string;
    isLoading: boolean;
    onRetake: () => void;
    onAnalyze: () => void;
}

export const PreviewView: React.FC<PreviewViewProps> = ({ imageUri, isLoading, onRetake, onAnalyze }) => (
   <View style={styles.previewContainer}>
      {/* Preview Header (Optional or simplify) */}
      <Image source={{ uri: imageUri }} style={styles.previewImage} resizeMode="contain"/>
      <View style={styles.previewControls}>
        <TouchableOpacity style={styles.retakeButton} onPress={onRetake} disabled={isLoading}>
           {/* ... Retake Button Content ... */}
        </TouchableOpacity>
        <TouchableOpacity style={styles.analyzeButton} onPress={onAnalyze} disabled={isLoading}>
           {/* ... Analyze Button Content (with ActivityIndicator) ... */}
        </TouchableOpacity>
      </View>
    </View>
);
 // Add relevant styles
const styles = StyleSheet.create({
    previewContainer: {
        flex: 1,
        backgroundColor: '#f8fafc', // Light background
      },
      previewImage: {
        flex: 1, // Take available space
        margin: 16,
        borderRadius: 12,
        backgroundColor: '#e2e8f0', // Placeholder bg
      },
      previewControls: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        padding: 16,
        borderTopWidth: 1,
        borderTopColor: '#e2e8f0',
        backgroundColor: '#ffffff', // White controls background
      },
      retakeButton: { // Consistent button style
        flexDirection: 'row',
        alignItems: 'center',
        backgroundColor: '#ffffff', // White background
        paddingVertical: 12,
        paddingHorizontal: 20,
        borderRadius: 8,
        borderWidth: 1,
        borderColor: '#cbd5e1', // Gray border
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 1 },
        shadowOpacity: 0.05,
        shadowRadius: 2,
        elevation: 1,
      },
      analyzeButton: { // Consistent button style
        flexDirection: 'row',
        alignItems: 'center',
        backgroundColor: '#3b82f6', // Blue background
        paddingVertical: 12,
        paddingHorizontal: 20,
        borderRadius: 8,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.15,
        shadowRadius: 4,
        elevation: 3,
      },
});

------------------------

/foodScanner\ResultsView.tsx :

// components/foodScanner/ResultsView.tsx // Assuming you moved it
import React from 'react';
import {
    View,
    Text,
    Image,
    ScrollView,
    TouchableOpacity,
    StyleSheet,
    Platform // <<< Import Platform
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { FoodItem } from '../../types'; // <<< Import FoodItem (adjust path if needed)
// Import styles if they are in a separate file
// import styles from './ResultsView.styles';

interface ResultsViewProps {
    imageUri?: string; // Stays optional
    foodData: FoodItem[]; // <<< Use imported FoodItem
    onAddToLog: () => void;
    // Add onRetake if needed: onRetake: () => void;
}

// Utility function can stay here or be imported if used elsewhere
// Ensure the input array is typed correctly
const calculateTotalNutrition = (foods: FoodItem[]) => {
    // Explicitly type the accumulator 'totals'
    return foods.reduce(
      (totals: { calories: number; protein: number; carbs: number; fat: number }, f: FoodItem) => ({
        calories: totals.calories + (f.kcal || 0),
        protein: totals.protein + (f.protein || 0),
        carbs: totals.carbs + (f.carbs || 0),
        fat: totals.fat + (f.fats || 0), // Use 'fats' based on interface
      }),
      // Initial value for the accumulator
      { calories: 0, protein: 0, carbs: 0, fat: 0 }
    );
};


export const ResultsView: React.FC<ResultsViewProps> = ({ imageUri, foodData, onAddToLog /*, onRetake */ }) => {
    const total = calculateTotalNutrition(foodData);
    const matchPercentage = "92%"; // Example

    return (
        <View style={styles.resultsContainer}>
             {/* Header - Add back button if needed */}
            {/* <View style={styles.resultsHeader}>
                 <TouchableOpacity onPress={onRetake} style={styles.backButton}>
                      <Ionicons name="arrow-back" size={24} color="white" />
                  </TouchableOpacity>
                  <Text style={styles.resultsTitle}>Analysis Results</Text>
                  <View style={{ width: 24 }}/>
            </View> */}

            <ScrollView style={styles.resultsScrollView}>
                <View style={styles.resultsCard}>
                    {imageUri && <Image source={{ uri: imageUri }} style={styles.resultImage} resizeMode="cover" />}

                    <View style={styles.foodMatched}>
                        <Text style={styles.foodMatchedName}>
                            {foodData[0]?.name || "Identified Food"}
                        </Text>
                        <View style={styles.matchBadge}>
                            <Text style={styles.matchText}>{matchPercentage} match</Text>
                        </View>
                    </View>

                    <View style={styles.nutritionSummary}>
                        <Text style={styles.nutritionLabel}>Total Estimated Calories</Text>
                        <Text style={styles.caloriesValue}>{Math.round(total.calories)} kcal</Text>

                        <View style={styles.macrosRow}>
                            <View style={styles.macroItem}>
                                <Text style={styles.macroLabel}>Protein</Text>
                                <Text style={styles.macroValue}>{total.protein.toFixed(1)}g</Text>
                            </View>
                            <View style={styles.macroItem}>
                                <Text style={styles.macroLabel}>Carbs</Text>
                                <Text style={styles.macroValue}>{total.carbs.toFixed(1)}g</Text>
                            </View>
                            <View style={styles.macroItem}>
                                <Text style={styles.macroLabel}>Fat</Text>
                                <Text style={styles.macroValue}>{total.fat.toFixed(1)}g</Text>
                            </View>
                        </View>
                    </View>
                </View>

                <View style={styles.identifiedItemsContainer}>
                    <Text style={styles.identifiedItemsTitle}>Identified Items Breakdown</Text>
                    {foodData.map((food: FoodItem, idx: number) => (
                        <View key={`${food.name}-${idx}`} style={styles.identifiedItem}>
                           {/* ... item details ... */}
                            <View style={styles.itemDetail}>
                                <Text style={styles.itemName}>{food.name}</Text>
                            </View>
                            <Text style={styles.itemCalories}>{food.kcal} cal</Text>
                        </View>
                    ))}
                </View>

                <Text style={styles.disclaimerText}>
                    Nutritional information is estimated...
                </Text>
            </ScrollView>

            <TouchableOpacity style={styles.addToLogButton} onPress={onAddToLog}>
                 <Ionicons name="add-circle-outline" size={22} color="white" />
                <Text style={styles.addToLogButtonText}>Add Items to Log</Text>
            </TouchableOpacity>
        </View>
    );
};

// Add relevant styles here or import them
const styles = StyleSheet.create({
    // Paste relevant styles from the original FoodScannerScreen.styles here
    // Example:
    resultsContainer: { flex: 1, backgroundColor: '#f8fafc' },
    resultsScrollView: { flex: 1 },
    resultsCard: { backgroundColor: 'white', margin: 16, borderRadius: 12, overflow: 'hidden', shadowColor: '#9ca3af', shadowOffset: { width: 0, height: 3 }, shadowOpacity: 0.2, shadowRadius: 5, elevation: 4 },
    resultImage: { width: '100%', height: 220, backgroundColor: '#e2e8f0' },
    foodMatched: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', paddingVertical: 10, paddingHorizontal: 16, backgroundColor: '#f1f5f9', borderBottomWidth: 1, borderBottomColor: '#e2e8f0' },
    foodMatchedName: { color: '#1e293b', fontSize: 18, fontWeight: '600', flex: 1, marginRight: 10 },
    matchBadge: { backgroundColor: '#16a34a', paddingVertical: 5, paddingHorizontal: 10, borderRadius: 15 },
    matchText: { color: 'white', fontSize: 12, fontWeight: '600' },
    nutritionSummary: { padding: 16 },
    nutritionLabel: { fontSize: 14, color: '#64748b', marginBottom: 4 },
    caloriesValue: { fontSize: 32, fontWeight: 'bold', color: '#1e293b', marginBottom: 16 },
    macrosRow: { flexDirection: 'row', justifyContent: 'space-between', borderTopWidth: 1, borderTopColor: '#f1f5f9', paddingTop: 16 },
    macroItem: { alignItems: 'center', flex: 1 },
    macroLabel: { fontSize: 13, color: '#64748b', marginBottom: 4, textTransform: 'uppercase', letterSpacing: 0.5 },
    macroValue: { fontSize: 18, fontWeight: '600', color: '#334155' },
    identifiedItemsContainer: { backgroundColor: 'white', marginHorizontal: 16, marginBottom: 16, borderRadius: 12, overflow: 'hidden', shadowColor: '#9ca3af', shadowOffset: { width: 0, height: 2 }, shadowOpacity: 0.15, shadowRadius: 4, elevation: 3 },
    identifiedItemsTitle: { fontSize: 16, fontWeight: '600', color: '#1e293b', padding: 16, borderBottomWidth: 1, borderBottomColor: '#f1f5f9' },
    identifiedItem: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', paddingVertical: 14, paddingHorizontal: 16, borderTopWidth: 1, borderTopColor: '#f1f5f9' },
    itemDetail: { flex: 1, marginRight: 10 },
    itemName: { fontSize: 15, fontWeight: '500', color: '#334155' },
    itemCalories: { fontSize: 15, fontWeight: '600', color: '#0ea5e9' },
    disclaimerText: { fontSize: 12, color: '#64748b', textAlign: 'center', marginHorizontal: 24, marginBottom: 24, lineHeight: 18 },
    addToLogButton: { backgroundColor: '#16a34a', marginHorizontal: 16, marginBottom: Platform.OS === 'ios' ? 25 : 16, marginTop: 8, borderRadius: 8, flexDirection: 'row', justifyContent: 'center', alignItems: 'center', paddingVertical: 16, shadowColor: '#000', shadowOffset: { width: 0, height: 2 }, shadowOpacity: 0.2, shadowRadius: 4, elevation: 4 },
    addToLogButtonText: { color: 'white', fontWeight: '600', fontSize: 16, marginLeft: 10 },
    // Add any other styles needed (e.g., backButton if you use it)
});

------------------------

/home\AddFoodModal.jsx :

import React from 'react';
import {
  Modal,
  View,
  Text,
  TouchableOpacity,
  TextInput,
  StyleSheet,
  FlatList,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';

export default function AddFoodModal({
  visible,
  onClose,
  searchQuery,
  setSearchQuery,
  filteredFoods,
  addFoodToMeal,
}) {
  return (
    <Modal
      visible={visible}
      animationType="slide"
      transparent
      onRequestClose={onClose}
    >
      <View style={styles.modalOverlay}>
        <View style={styles.modalContent}>
          {/* Header */}
          <View style={styles.modalHeader}>
            <Text style={styles.modalTitle}>Add Food</Text>
            <TouchableOpacity style={styles.closeButton} onPress={onClose}>
              <Ionicons name="close" size={24} color="#000" />
            </TouchableOpacity>
          </View>

          {/* Search Input */}
          <TextInput
            style={styles.searchInput}
            placeholder="Search foods..."
            value={searchQuery}
            onChangeText={setSearchQuery}
            autoFocus
          />

          {/* Food List */}
          <FlatList
            data={filteredFoods}
            keyExtractor={(item) => item.id}
            style={styles.foodList}
            renderItem={({ item }) => (
              <TouchableOpacity
                style={styles.foodListItem}
                onPress={() => addFoodToMeal(item)}
              >
                <View>
                  <Text style={styles.foodListItemName}>{item.name}</Text>
                  <Text style={styles.foodListItemCalories}>
                    {item.caloriesPer100g} cal / 100g
                  </Text>
                </View>

                <View style={styles.foodListMacros}>
                  <Text style={styles.foodListMacro}>P: {item.proteinPer100g}g</Text>
                  <Text style={styles.foodListMacro}>C: {item.carbsPer100g}g</Text>
                  <Text style={styles.foodListMacro}>F: {item.fatPer100g}g</Text>
                </View>
              </TouchableOpacity>
            )}
          />
        </View>
      </View>
    </Modal>
  );
}

const styles = StyleSheet.create({
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'flex-end',
  },
  modalContent: {
    backgroundColor: '#FFFFFF',
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    paddingHorizontal: 20,
    paddingBottom: Platform.OS === 'ios' ? 40 : 20,
    paddingTop: 20,
    maxHeight: '80%',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 15,
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
  },
  closeButton: {
    padding: 5,
  },
  searchInput: {
    backgroundColor: '#F5F5F5',
    borderRadius: 10,
    paddingHorizontal: 15,
    paddingVertical: 10,
    marginBottom: 15,
  },
  foodList: {
    maxHeight: 400,
  },
  foodListItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#EEEEEE',
  },
  foodListItemName: {
    fontSize: 16,
    color: '#333',
  },
  foodListItemCalories: {
    fontSize: 14,
    color: '#666',
    marginTop: 2,
  },
  foodListMacros: {
    flexDirection: 'row',
  },
  foodListMacro: {
    fontSize: 12,
    color: '#666',
    marginLeft: 8,
  },
});


------------------------

/home\Header.jsx :

import React from 'react';
import {
  View,
  Text,
  StyleSheet,
  SafeAreaView,
  StatusBar,
} from 'react-native';

const Header = ({ title = 'Andrei', subtitle = new Date().toDateString() }) => {
  return (
    <>
      <StatusBar backgroundColor="#2962FF" barStyle="light-content" />
      <SafeAreaView style={styles.safeArea}>
        <View style={styles.headerContainer}>
          <Text style={styles.title}>{title}</Text>
          <Text style={styles.subtitle}>{subtitle}</Text>
        </View>
      </SafeAreaView>
    </>
  );
};

const styles = StyleSheet.create({
  safeArea: {
    backgroundColor: '#2962FF',
  },
  headerContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#2962FF',
    paddingVertical: 10,
    paddingHorizontal: 16,
    elevation: 3,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.08,
    shadowRadius: 2,
  },
  title: {
    color: '#FFFFFF',
    fontSize: 17,
    fontWeight: '700',
  },
  subtitle: {
    color: '#e3f2fd',
    fontSize: 13,
    fontWeight: '400',
  },
});

export default Header;


------------------------

/home\MealCard.jsx :

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

export default function MealCard({ meal, totalCalories, nutrients }) {
  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.mealName}>{meal.name}</Text>
        <Text style={styles.mealTime}>{meal.time}</Text>
      </View>

      <View style={styles.summary}>
        <Text style={styles.items}>
          {meal.foods.length} {meal.foods.length === 1 ? 'item' : 'items'}
        </Text>
        <Text style={styles.calories}>{totalCalories} cal</Text>
      </View>

      <View style={styles.macrosContainer}>
        <View style={styles.macro}>
          <Text style={styles.macroLabel}>Protein</Text>
          <Text style={styles.macroValue}>{nutrients.protein}g</Text>
        </View>
        <View style={styles.macro}>
          <Text style={styles.macroLabel}>Carbs</Text>
          <Text style={styles.macroValue}>{nutrients.carbs}g</Text>
        </View>
        <View style={styles.macro}>
          <Text style={styles.macroLabel}>Fat</Text>
          <Text style={styles.macroValue}>{nutrients.fat}g</Text>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    backgroundColor: '#FFFFFF',
    borderRadius: 10,
    padding: 12,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.06,
    shadowRadius: 2,
    elevation: 2,
    borderLeftWidth: 3,
    borderLeftColor: '#2196F3',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 4,
  },
  mealName: {
    fontSize: 15,
    fontWeight: '600',
    color: '#333',
  },
  mealTime: {
    fontSize: 12,
    color: '#666',
  },
  summary: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 6,
  },
  items: {
    fontSize: 12,
    color: '#666',
  },
  calories: {
    fontSize: 12,
    fontWeight: '500',
    color: '#333',
  },
  macrosContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    backgroundColor: '#F5F9FF',
    padding: 8,
    borderRadius: 8,
  },
  macro: {
    alignItems: 'center',
    flex: 1,
  },
  macroLabel: {
    fontSize: 11,
    color: '#555',
    marginBottom: 2,
  },
  macroValue: {
    fontSize: 13,
    fontWeight: '600',
    color: '#333',
  },
});


------------------------

/home\MealModal.jsx :

import React from 'react';
import {
  Modal,
  View,
  Text,
  TouchableOpacity,
  TextInput,
  StyleSheet,
  Platform,
  ScrollView,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';

export default function MealModal({
  visible,
  selectedMeal,
  isNewMeal,
  newMealName,
  setNewMealName,
  newMealTime,
  setNewMealTime,
  closeMealModal,
  saveMeal,
  startEditingQuantity,
  editingFoodId,
  editingQuantity,
  setEditingQuantity,
  saveQuantity,
  removeFood,
  openAddFoodModal,
}) {
  if (!selectedMeal) return null;

  return (
    <Modal
      visible={visible}
      animationType="slide"
      transparent
      onRequestClose={closeMealModal}
    >
      <View style={styles.modalOverlay}>
        <View style={styles.modalContent}>
          {/* Header: Meal name & close button */}
          <View style={styles.modalHeader}>
            {isNewMeal ? (
              <TextInput
                style={styles.mealNameInput}
                value={newMealName}
                onChangeText={setNewMealName}
                placeholder="Meal name"
              />
            ) : (
              <Text style={styles.modalTitle}>{selectedMeal.name}</Text>
            )}

            <TouchableOpacity style={styles.closeButton} onPress={closeMealModal}>
              <Ionicons name="close" size={24} color="#000" />
            </TouchableOpacity>
          </View>

          {/* Meal time */}
          <View style={styles.mealTimeContainer}>
            {isNewMeal ? (
              <TextInput
                style={styles.mealTimeInput}
                value={newMealTime}
                onChangeText={setNewMealTime}
                placeholder="Time (e.g., 8:00 AM)"
              />
            ) : (
              <Text style={styles.mealTimeText}>{selectedMeal.time}</Text>
            )}
          </View>

          {/* Foods list */}
          <ScrollView style={{ maxHeight: 300 }}>
            {selectedMeal.foods && selectedMeal.foods.length > 0 ? (
              selectedMeal.foods.map((food) => (
                <View key={food.id} style={styles.foodItem}>
                  <View style={styles.foodInfo}>
                    <Text style={styles.foodName}>{food.name}</Text>
                    <View style={styles.foodNutrients}>
                      <Text style={styles.foodCalories}>{food.calories} cal</Text>
                      <Text style={styles.foodNutrient}>P: {food.protein}g</Text>
                      <Text style={styles.foodNutrient}>C: {food.carbs}g</Text>
                      <Text style={styles.foodNutrient}>F: {food.fat}g</Text>
                    </View>
                  </View>

                  <View style={styles.foodActions}>
                    {editingFoodId === food.id ? (
                      <View style={styles.quantityEditContainer}>
                        <TextInput
                          style={styles.quantityInput}
                          value={editingQuantity}
                          onChangeText={setEditingQuantity}
                          keyboardType="numeric"
                          autoFocus
                        />
                        <Text style={styles.unitText}>g</Text>
                        <TouchableOpacity
                          style={styles.saveButton}
                          onPress={() => saveQuantity(selectedMeal.id, food.id)}
                        >
                          <Ionicons name="checkmark" size={20} color="#4CAF50" />
                        </TouchableOpacity>
                      </View>
                    ) : (
                      <TouchableOpacity
                        style={styles.quantityContainer}
                        onPress={() => startEditingQuantity(food.id, food.quantity)}
                      >
                        <Text style={styles.quantityText}>
                          {food.quantity}g
                        </Text>
                        <Ionicons name="create-outline" size={16} color="#2196F3" />
                      </TouchableOpacity>
                    )}

                    <TouchableOpacity
                      style={styles.removeButton}
                      onPress={() => removeFood(selectedMeal.id, food.id)}
                    >
                      <Ionicons name="trash-outline" size={20} color="#FF3B30" />
                    </TouchableOpacity>
                  </View>
                </View>
              ))
            ) : (
              <View style={styles.emptyFoodList}>
                <Text style={styles.emptyFoodListText}>
                  No food items added yet. Add your first item below.
                </Text>
              </View>
            )}
          </ScrollView>

          {/* Action buttons: Add Food, Save Meal */}
          <View style={styles.actionButtonsContainer}>
            <TouchableOpacity style={styles.addFoodButton} onPress={openAddFoodModal}>
              <Ionicons name="add-circle-outline" size={20} color="#FFFFFF" />
              <Text style={styles.addFoodText}>Add Food</Text>
            </TouchableOpacity>

            {isNewMeal && (
              <TouchableOpacity
                style={[
                  styles.saveMealButton,
                  { opacity: selectedMeal.foods.length === 0 ? 0.5 : 1 },
                ]}
                onPress={saveMeal}
                disabled={selectedMeal.foods.length === 0}
              >
                <Ionicons name="checkmark-circle-outline" size={20} color="#FFFFFF" />
                <Text style={styles.saveMealText}>Save Meal</Text>
              </TouchableOpacity>
            )}
          </View>
        </View>
      </View>
    </Modal>
  );
}

const styles = StyleSheet.create({
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'flex-end',
  },
  modalContent: {
    backgroundColor: '#FFFFFF',
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    paddingHorizontal: 20,
    paddingBottom: Platform.OS === 'ios' ? 40 : 20,
    paddingTop: 20,
    maxHeight: '80%',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 15,
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
    flex: 1,
  },
  mealNameInput: {
    fontSize: 20,
    fontWeight: 'bold',
    borderBottomWidth: 1,
    borderBottomColor: '#ddd',
    paddingBottom: 5,
    color: '#333',
    flex: 1,
  },
  closeButton: {
    padding: 5,
  },
  mealTimeContainer: {
    marginBottom: 15,
  },
  mealTimeInput: {
    fontSize: 14,
    color: '#666',
    borderBottomWidth: 1,
    borderBottomColor: '#ddd',
    paddingBottom: 5,
  },
  mealTimeText: {
    fontSize: 14,
    color: '#666',
  },
  foodItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#EEEEEE',
  },
  foodInfo: {
    flex: 1,
  },
  foodName: {
    fontSize: 16,
    color: '#333',
    marginBottom: 4,
  },
  foodNutrients: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  foodCalories: {
    fontSize: 14,
    color: '#666',
    marginRight: 10,
  },
  foodNutrient: {
    fontSize: 13,
    color: '#777',
    marginRight: 8,
  },
  foodActions: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  quantityContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#F0F0F0',
    borderRadius: 6,
    paddingHorizontal: 10,
    paddingVertical: 5,
    marginRight: 10,
  },
  quantityText: {
    marginRight: 5,
    color: '#333',
  },
  quantityEditContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginRight: 10,
  },
  quantityInput: {
    backgroundColor: '#F0F0F0',
    width: 50,
    borderRadius: 6,
    paddingHorizontal: 8,
    paddingVertical: 5,
    textAlign: 'center',
  },
  unitText: {
    marginHorizontal: 5,
    color: '#333',
  },
  saveButton: {
    padding: 5,
  },
  removeButton: {
    padding: 5,
  },
  emptyFoodList: {
    padding: 30,
    alignItems: 'center',
    justifyContent: 'center',
  },
  emptyFoodListText: {
    textAlign: 'center',
    color: '#999',
    fontSize: 14,
  },
  actionButtonsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 20,
  },
  addFoodButton: {
    backgroundColor: '#2196F3',
    borderRadius: 10,
    paddingVertical: 12,
    paddingHorizontal: 16,
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    flex: 1,
    marginRight: 10,
  },
  addFoodText: {
    color: '#FFFFFF',
    fontWeight: '600',
    marginLeft: 8,
  },
  saveMealButton: {
    backgroundColor: '#4CAF50',
    borderRadius: 10,
    paddingVertical: 12,
    paddingHorizontal: 16,
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    flex: 1,
  },
  saveMealText: {
    color: '#FFFFFF',
    fontWeight: '600',
    marginLeft: 8,
  },
});


------------------------

/home\MealsList.jsx :

import React from 'react';
import { View, TouchableOpacity } from 'react-native';
import MealCard from './MealCard';

export default function MealsList({
  meals = [],
  onMealPress,
  calculateMealCalories,
  calculateMealNutrients,
  emptyStateComponent,
}) {
  // If no meals, render an optional empty state from parent or a simple fallback
  if (meals.length === 0) {
    return emptyStateComponent || null;
  }

  return (
    <View>
      {meals.map((meal) => {
        const totalCalories = calculateMealCalories(meal.foods);
        const nutrients = calculateMealNutrients(meal.foods);

        return (
          <TouchableOpacity
            key={meal.id}
            style={{ marginBottom: 16 }}
            onPress={() => onMealPress(meal)}
            activeOpacity={0.9}
          >
            <MealCard
              meal={meal}
              totalCalories={totalCalories}
              nutrients={nutrients}
            />
          </TouchableOpacity>
        );
      })}
    </View>
  );
}


------------------------

/home\NutritionTracker.jsx :

import React, { useEffect, useRef, useState } from 'react'; // Added useState import
import { View, Text, StyleSheet, Animated } from 'react-native'; // Make sure StyleSheet is imported if styles are defined elsewhere or passed as props
import Svg, { Path, Text as SvgText } from 'react-native-svg';

// ------- Helper Function for Arc Path -------
// (Keep this function as it's essential for LeftArcProgress)
function describeArc(x, y, radius, startAngle, endAngle) {
    const startRad = (startAngle - 90) * Math.PI / 180.0;
    const endRad = (endAngle - 90) * Math.PI / 180.0;

    // Ensure angles are valid numbers, default if not
    const validStartAngle = isNaN(startAngle) ? 0 : startAngle;
    const validEndAngle = isNaN(endAngle) ? 0 : endAngle;

    const angleDiff = validEndAngle - validStartAngle;
    const positiveAngleDiff = (angleDiff % 360 + 360) % 360;

     if (Math.abs(positiveAngleDiff) < 0.01 || Math.abs(positiveAngleDiff - 360) < 0.01 ) {
         return "";
    }

    const largeArcFlag = positiveAngleDiff <= 180 ? "0" : "1";
    const sweepFlag = "1";

    const startX = x + radius * Math.cos(startRad);
    const startY = y + radius * Math.sin(startRad);
    const endX = x + radius * Math.cos(endRad);
    const endY = y + radius * Math.sin(endRad);

    if (isNaN(startX) || isNaN(startY) || isNaN(endX) || isNaN(endY)) {
        console.error("NaN coordinate detected in describeArc", { x, y, radius, startAngle, endAngle, startRad, endRad });
        return "";
    }

    return [
        "M", startX, startY,
        "A", radius, radius, 0, largeArcFlag, sweepFlag, endX, endY
    ].join(" ");
}

const TOTAL_ARC_SWEEP_ANGLE = 180;
const ARC_START_ANGLE = -90;

// ------- LeftArcProgress Component -------
const LeftArcProgress = ({
    value, // Prop can still be potentially non-numeric
    maxValue,
    radius = 80, // Default value using JS destructuring
    strokeWidth = 8,
    activeColor = '#3498db',
    inactiveColor = '#e8e8e8',
    valueColor = '#2c3e50',
    suffixColor = '#7f8c8d',
    subtitleColor = '#555555',
}) => {
    // Ensure numeric values, default to 0
    const numericValue = Number(value) || 0;
    const numericMaxValue = Number(maxValue) || 0;

    const safeMaxValue = numericMaxValue > 0 ? numericMaxValue : 1; // Avoid division by zero
    const percentage = Math.max(0, Math.min(1, numericValue / safeMaxValue)); // Cap percentage

    const animatedProgress = useRef(new Animated.Value(percentage)).current; // Initialize with current percentage

    // Animate when percentage changes
    useEffect(() => {
        Animated.timing(animatedProgress, {
            toValue: percentage,
            duration: 800,
            useNativeDriver: false,
        }).start();
    }, [percentage, animatedProgress]);

    const svgSize = radius * 2 + strokeWidth * 2;
    const center = svgSize / 2;
    const backgroundPath = describeArc(center, center, radius, ARC_START_ANGLE, ARC_START_ANGLE + TOTAL_ARC_SWEEP_ANGLE);
    const valueY = center - 20;
    const subtitleY = center;

    const [progressPath, setProgressPath] = useState(''); // Use React.useState or just useState

    // Listener to update the path string based on animation
    useEffect(() => {
        const listenerId = animatedProgress.addListener(({ value: animatedPercentageValue }) => {
            const currentAngle = ARC_START_ANGLE + Math.min(1, Math.max(0, animatedPercentageValue)) * TOTAL_ARC_SWEEP_ANGLE;
            const clampedAngle = Math.max(ARC_START_ANGLE, Math.min(ARC_START_ANGLE + TOTAL_ARC_SWEEP_ANGLE, currentAngle));
            const path = describeArc(center, center, radius, ARC_START_ANGLE, clampedAngle);
            setProgressPath(path || '');
        });

        // Set initial path correctly
        const initialAngle = ARC_START_ANGLE + Math.min(1, Math.max(0, animatedProgress._value)) * TOTAL_ARC_SWEEP_ANGLE;
        const initialPath = describeArc(center, center, radius, ARC_START_ANGLE, initialAngle);
        setProgressPath(initialPath || '');

        return () => {
            animatedProgress.removeListener(listenerId);
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [animatedProgress]);

    return (
        <View style={{ alignItems: 'center', marginBottom: -60, marginTop: 5 }}>
            <Svg width={svgSize} height={svgSize} viewBox={`0 0 ${svgSize} ${svgSize}`}>
                <Path
                    d={backgroundPath}
                    stroke={inactiveColor}
                    strokeWidth={strokeWidth}
                    strokeLinecap="round"
                    fill="none"
                />
                {progressPath ? (
                    <Path
                        d={progressPath}
                        stroke={activeColor}
                        strokeWidth={strokeWidth}
                        strokeLinecap="round"
                        fill="none"
                    />
                ) : null}
                <SvgText
                    x={center}
                    y={valueY}
                    fill={valueColor}
                    fontSize={28}
                    fontWeight="600"
                    textAnchor="end"
                    alignmentBaseline="middle"
                    dx="5"
                >
                    {Math.round(numericValue)}
                </SvgText>
                <SvgText
                    x={center + 10}
                    y={valueY}
                    fill={suffixColor}
                    fontSize={16}
                    fontWeight="400"
                    textAnchor="start"
                    alignmentBaseline="middle"
                >
                    {` / ${Math.round(numericMaxValue)}`}
                </SvgText>
                <SvgText
                    x={center}
                    y={subtitleY}
                    fill={subtitleColor}
                    fontSize={12}
                    fontWeight="400"
                    textAnchor="middle"
                    alignmentBaseline="middle"
                >
                    Kcals consumed
                </SvgText>
            </Svg>
        </View>
    );
};

// ------- MacroBar Component -------
const MacroBar = ({ label, color, currentValue, maxValue }) => {
    // Ensure numeric values, default to 0
    const numericCurrentValue = Number(currentValue) || 0;
    const numericMaxValue = Number(maxValue) || 0;

    const safeMaxValue = numericMaxValue > 0 ? numericMaxValue : 1;
    const percentage = Math.max(0, Math.min(1, numericCurrentValue / safeMaxValue));

    const animatedWidthPercent = useRef(new Animated.Value(percentage * 100)).current; // Initialize with current percentage

    // Animate when percentage changes
    useEffect(() => {
        Animated.timing(animatedWidthPercent, {
            toValue: percentage * 100,
            duration: 800,
            useNativeDriver: false,
        }).start();
    }, [percentage, animatedWidthPercent]);

    return (
        // Assumes styles.macroBarContainer etc. are defined/imported
        <View style={styles.macroBarContainer}>
            <View style={styles.macroTopRow}>
                <Text style={[styles.macroLabel, { color: color }]}>{label}</Text>
            </View>
            <View style={styles.macroProgressBarBackground}>
                <Animated.View
                    style={[
                        styles.macroProgressBarFill,
                        {
                            backgroundColor: color,
                            width: animatedWidthPercent.interpolate({
                                inputRange: [0, 100],
                                outputRange: ['0%', '100%']
                            })
                        }
                    ]}
                />
            </View>
            <View style={styles.macroBottomRow}>
                <Text style={styles.macroCurrentValue}>{numericCurrentValue.toFixed(1)}g</Text>
                <Text style={styles.macroMaxValue}>{Math.round(numericMaxValue)}g</Text>
            </View>
        </View>
    );
};


// ------- NutritionTracker Component -------
const NutritionTracker = ({
    caloriesConsumed,
    calorieGoal,
    carbsConsumed,
    carbGoal,
    proteinConsumed,
    proteinGoal,
    fatConsumed,
    fatGoal,
}) => {
    // Validate props, default to 0 if invalid input
    const validCaloriesConsumed = Number(caloriesConsumed) || 0;
    const validCalorieGoal = Number(calorieGoal) || 0;
    const validCarbsConsumed = Number(carbsConsumed) || 0;
    const validCarbGoal = Number(carbGoal) || 0;
    const validProteinConsumed = Number(proteinConsumed) || 0;
    const validProteinGoal = Number(proteinGoal) || 0;
    const validFatConsumed = Number(fatConsumed) || 0;
    const validFatGoal = Number(fatGoal) || 0;

    // Pass validated numbers down to child components
    // Assumes styles.card and styles.macrosRow are defined/imported
    return (
        <View style={styles.card}>
            <LeftArcProgress
                value={validCaloriesConsumed}
                maxValue={validCalorieGoal}
                activeColor="#3498db"
            />
            <View style={styles.macrosRow}>
                <MacroBar label="Carbs" color="#3498db" currentValue={validCarbsConsumed} maxValue={validCarbGoal} />
                <MacroBar label="Protein" color="#9b59b6" currentValue={validProteinConsumed} maxValue={validProteinGoal} />
                <MacroBar label="Fat" color="#f39c12" currentValue={validFatConsumed} maxValue={validFatGoal} />
            </View>
        </View>
    );
};

const styles = StyleSheet.create({
    card: {
        backgroundColor: '#ffffff',
        borderRadius: 10,
        paddingVertical: 10,
        paddingHorizontal: 14,
        shadowColor: "#000",
        shadowOffset: { width: 0, height: 1 },
        shadowOpacity: 0.1,
        shadowRadius: 2,
        elevation: 2,
    },
    macrosRow: {
        flexDirection: 'row',
        justifyContent: 'space-between',
    },
    macroBarContainer: {
        flex: 1,
        marginHorizontal: 4,
    },
    macroTopRow: {
        flexDirection: 'row',
        justifyContent: 'flex-start',
        alignItems: 'center',
        marginBottom: 4,
        height: 18,
    },
    macroLabel: {
        fontSize: 13,
        fontWeight: '600',
    },
    macroProgressBarBackground: {
        height: 6,
        backgroundColor: '#f0f0f0',
        borderRadius: 5,
        overflow: 'hidden',
        marginBottom: 4,
    },
    macroProgressBarFill: {
        height: '100%',
        borderRadius: 5,
    },
    macroBottomRow: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginTop: 1,
    },
    macroCurrentValue: {
        fontSize: 12,
        fontWeight: '600',
        color: '#444444',
    },
    macroMaxValue: {
        fontSize: 12,
        color: '#999999',
    },
});

export default NutritionTracker;

------------------------

